{ ---------------------------------------start------------------------------------------ }

: clear  (  -- remove stack values )
	depth 1 + 1 do i drop . loop ;             { depth 1 + is the number of values in stack +1, since the loop take n-1 as  the end }
                                               { start with 1, operate the drop for the index appointed value in stack, drop from the top }


{ Qs  a }

: square_print cr
	101 1 do i dup * . loop ;                 { word that print the square of 1-100 } 

{ Qs  b }


{ -----------------------------Global variables------------------------------ }

variable array-size                    { number of elements for the square matrix  }
variable array-dim                     { dimension number for the square matrix }



200 array-dim !
200 dup * array-size !


{ ---------------------------------------------------------------------------- }

	
array-size @   allocate drop constant array     { create n*n elements , drop the 0 flag, return address to top stack }



: show 	(  -- print array in matrix form )             { word to print the array defined }
	cr                                                 { start from the next line }
	array-size @ 0 do array i + c@   5 .r              { print values with 5 spaces between elements  }
	i 1 +                                              { set up the conditon to return to next line } 
	array-dim @ mod 0=                                 { jumping point }
	if cr                                              { at every 10th value jump }
	then loop ;


{---------------------------------------adding random number to array-------------------------------------  }

CREATE SEED  123475689 ,

: Rnd ( n -- rondam number )   { Returns single random number less than n }
   SEED              { Minimal version of SwiftForth Rnd.f      }
   DUP >R            { Algorithm Rick VanNorman  rvn@forth.com  }
   @ 127773 /MOD 
   2836 * SWAP 16807 * 
   2DUP > IF - 
   ELSE - 2147483647 +  
   THEN  DUP R> !
   SWAP MOD ;
   
   
: random_! ( n -- array )                  { word for entering random number 0 - 9 }
	
	array-size @ 0                         { set indices for array }
	do 9 Rnd array i + c!                  { adding random number to the array }
	loop ;

{ -------------------------------------find number of elements in the matrix-------------------------------- }

 
create count_ar 4 9 * allot

: reset_cou 36 0 do 0 count_ar  i + ! loop ;

: show_cou
	
	cr
	." number "
	cr                                   
	9 0 do i  7 .r  loop                                                { making titles }
	cr
	." counts "
	cr
	36 0 do i 4 mod 0= if count_ar i + @  7 .r then loop ;              { display number of counts from every 4th element }

: count 
	reset_cou                                                                  { reset counter to 0 }
	cr 
	array-size @ 0 
	do  10 0 do                                     
	array j + c@                                                               { reading element from array }
    i =                                                                        { the reading is used to compare with number 0~9 } 
	if count_ar i 4 * + @    1 +    count_ar i 4 *   + !                       { taking every 4 th value in 32 bit array, if the reading equals 0~9 the increment the correponding counts stack }
	then
	loop loop ;
	
: c              { testing counter for number 1 }
	cr 
	array-size @ 0 
	do  
	array i + c@ 
	1 =
	if count_ar 1 4 * + @     1 +     count_ar 1 4 *   + ! then              
	loop ;


{ -----------------------------------------------life rule---------------------------------------------------- }


: #_neighbour ( array address --- )
	
	
	array-size @ array-dim @ live-cell @ locals| x n nn add |                      { define local constants n - array-dim, nn - array-size, x - live cell number }
																				   { add - entered address of array }
	nn 0 do 
	
	{ not at boundry }
	{ add the reading from 8 surrounding elements and store to array_#_live }
	
	add i 1 +  + c@  add i 1 -  + c@  +
	add i n +  + c@  +  add i n -  + c@  +
	add i n + 1 -  + c@  +  add i n + 1 +  + c@  +
	add i n - 1 -  + c@  +  add i n - 1 +  + c@  +
	array_#_live i + c!
	
	
	case 
		i                                                                       { take index from the outter do-loop }
	{ corners }
	{ add the reading from 3 surrounding elements and store to array_#_live }
	 
		0 of 0 drop                                                             { 0 left top }
				add i 1 +  + c@  add i n +  + c@  +  add i n + 1 +  + c@  + 
				array_#_live i + c! endof                                       { add the reading from 3 surrounding elements and store to array_#_live }
				
		n 1 - of n 1 - drop                                                    { n-1 right top }
				add i 1 -  + c@  add i n +  + c@  +  add i n + 1 -  + c@  +
				array_#_live i + c! endof                                       
				
		n square n - of n square n - drop                                     { n^2 -n left bot }  
				add i 1 +  + c@  add i n -  + c@  +  add i n - 1 +  + c@  +
				array_#_live i + c! endof                                    
				
		n square 1 - of n square 1 - drop                                     { n^2 - 1 right bot }
				add i 1 -  + c@  add i n -  + c@  +  add i n - 1 -  + c@  +
				array_#_live i + c! endof                                       
		
	endcase 
	
	{ sides }
	{ add the reading from 5 surrounding elements and store to array_#_live }
	
	
		n 1 -     1                  do  i j =                                                  { 1 ~ n-2 top side, compare the indices from 2 loops }
			
				if add i 1 -  + c@  add i 1 +  + c@  +  add i n +  + c@  +                       
				add i n + 1 -  + c@  +  add i n + 1 +  + c@  +
				array_#_live j + c!     
				 
		then loop
		
		
		n square 1 -     n square n - 1 +        do i j =                                                   { (n-1)n+1, (n-1)n+2,..., n^2 -2  bot side }
		
				if add i 1 -  + c@  add i 1 +  + c@  +  add i n -  + c@  +
				add i n - 1 -  + c@  +  add i n - 1 +  + c@  +
				array_#_live j + c!
		
		then loop
		
		
		
		n square n 2 * - 1 +     n        do i j =                                                    { n, 2n ....., n(n-2) left side }
				
				if add i n +  + c@  add i n -  + c@  +  add i 1 +  + c@  +
				add i 1 + n -  + c@  +  add i 1 + n +  + c@  +
				array_#_live j + c!
				
		then n +loop                                                                                  { jump n elements for entering the following row, inner loop }
		
	
	
		n square n -    n 2 * 1 -      do i j =                                                     { 2n-1,..., (n-1)n-1 right side }
				
				if add i n +  + c@  add i n -  + c@  +  add i 1 -  + c@  +
				add i 1 - n -  + c@  +  add i 1 - n +  + c@  +
				array_#_live j + c!
	
	
		then n +loop                                                                                   { jump n elements for entering the following row, inner loop }
	
	
		
	loop ;


: a     ( -- nn n )    { test for local constant }  
	array-size @ array-dim @ locals| n nn add |
	 add
	;

{ ----------------------------------------------command----------------------------------------------------- } 

\random_!
\count
\show_cou 














